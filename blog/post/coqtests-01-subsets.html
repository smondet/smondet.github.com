<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- Generated with Dibrawi, BraceTax, Sebib, and some more hacks -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<style type="text/css">
body {
   color: #020202;
   background-color: #fff;
}
div.content {
   color: #020202;
   background-color: #fff;
}
div.sidepane {
   color: #020202;
   background-color: #fff;
}
 {
   color: #020202;
   background-color: #fff;
}
a:link {
   color: #B41D1D;
}
a:visited {
   color: #671010;
}
a:hover {
   background-color: #BFFCD1;
}
tt {
   color: #1B3A23;
}pre {
   color: #1B3A23;
}code {
   color: #1B3A23;
}
.dbwmixcode {
   background-color: #BFFCD1;
}
div.figure:after {
   color: #B41D1D;
}caption.tablefigure:after {
   color: #B41D1D;
}
body {
   font-family: serif;
   text-align: left;
   font-size: 90%;

}
 {
   font-family: serif;
   text-align: left;
   font-size: 90%;

}
div.header {
   text-align: center;

}
h1 {
   font-size: 200%;
   font-variant: small-caps;

}
div.authors {
   font-size: 110%;

}
div.subtitle {
   font-size: 110%;
   font-style: italic;
}
h2 {
   font-size: 180%;

}
h3 {
   font-size: 150%;

}
h4 {
   font-size: 130%;

}
h5 {
   font-size: 108%;

}
a {
   text-decoration: underline thin;
}
tt,code,pre {
   font-family: monospace;

}
div.figure,div.tablefigure {
   font-size: 90%;

}
.content body {
   font-family: serif;
   text-align: justify;
   font-size: 100%;

}
.content  {
   font-family: serif;
   text-align: justify;
   font-size: 100%;

}
.content div.header {
   text-align: center;

}
.content h1 {
   font-size: 200%;
   font-variant: small-caps;

}
.content div.authors {
   font-size: 110%;

}
.content div.subtitle {
   font-size: 110%;
   font-style: italic;
}
.content h2 {
   font-size: 180%;

}
.content h3 {
   font-size: 150%;

}
.content h4 {
   font-size: 130%;

}
.content h5 {
   font-size: 108%;

}
.content a {
   text-decoration: underline thin;
}
.content tt,code,pre {
   font-family: monospace;

}
.content div.figure,div.tablefigure {
   font-size: 90%;

}
div.header {
    text-align: center;
    border:  #B41D1D solid 5px;
    padding-top:    2.1em;
    padding-bottom: 2.05em;
    margin-bottom: 3em;
}
div.p {
    padding-bottom: 0em;
}
div.p + div.p { padding-top: 0.5em; }
body {overflow: auto;}
code,pre {overflow: auto}
blockquote {
    border-left: 2px solid #020202;
    padding-left: 1em;
}
ul, ol {
    padding-top: 0em;
    padding-bottom: 0em;
    padding-left:  1.8em;
    margin-top: 0em;
    margin-bottom: 0em;
}
.dibrawicomment:before { content:  "["; }
.dibrawicomment:after { content: "]"; }
.dibrawicomment {
    background-color: yellow;
    color: red;
}
.dibrawimenudir { display: block; }
         ul  li.dibrawi_menuli {
           display: inline;
         } 
         ul.dibrawi_menuul {
           padding: 0em;
           margin: 0em;
           margin-left: 1em;
         }
table.tablefigure {
    margin-right:auto;
    margin-left: auto;
    border-collapse: collapse;
    min-width: 80%;
    margin-bottom: 1em;
}
caption.tablefigure {
    caption-side:bottom;
}
div.figure:after, caption.tablefigure:after { content: " [" attr(id) "]"; }
td, th {
    padding: 0.4em;
}
img {
    border: none;
    padding-bottom: 0.5em;
}div.figure, div.tablefigure {
    text-align: center;
    font-size:90%;
    border: thin #959595 solid;
    padding: 1ex;
    margin: 1em;
    width: 90%;
    margin-left: 5%;
    margin-right: 0em;
    clear: both;

}
small.notebegin { font-size: 70%; vertical-align: super; counter-increment: footnote; }
small.noteend { font-size: 70%; vertical-align: super; }
small.noteend:before {  content: counter(footnote) }
small.note:before { content: counter(footnote) ": " }
body { counter-reset: section subsection subsubsection footnote; }

small.note {
    font-size: 76%;
    clear: right;
    width: 32%;
    border: thin #959595 solid;
    float: right;
    margin: 0.5em;
    margin-right: 0em;
    padding: 0.5em;
}
h2 { border: #B41D1D solid 2px; padding: 0.2em; }
h3 { text-decoration: underline;}
pre {
    position: relative; left: 5%; max-width: 90%; clear: left;
}
div.sidepane {
  left: 0.5%; width: 19.000000%; padding: 0.5%;
  border-right: #B41D1D ridge 1px;
    top: 2px;
    position:fixed;
    overflow: auto;
    bottom: 2px;
}
div.content {
max-width : 45em; left: 21.000000%; right: 0.5%; padding: 0.2em;
    top: 2px;
    position: absolute;
}
</style>
<link rel="shortcut icon" href="http://seb.mondet.org/images/sm.ico">
<link rel="alternate" type="application/rss+xml" title="RSS" href="http://seb.mondet.org/blog/feed/all_posts.rss">
<title>Seb's Blog: Coq Programming with Subsets</title>
</head>
<body>
<div class="content">
<div class="p"></div>
<h2 id="Coq_Programming_with_Subsets">Coq Programming with Subsets</h2>
<div class="p"> <small> âž²&nbsp;&nbsp;<b>Date:</b> <i>Wed, 17 Aug 2011 21:01:56 +0200</i>; <b>Tags:</b> <tt>[<a href="../feed/ocaml.rss"><tt>ocaml</tt></a>; <a href="../feed/coq.rss"><tt>coq</tt></a>]</tt>. </small><br/>
<br/>
             </div>
<div class="p">  For me, the future of programming should be to keep coding in OCaml, and start replacing some modules by formally proved Coq code. The <i>direct</i> Coq code would be extracted to OCaml, or would be <i>generating</i> the 1%  performance-critical code which needs to be  (meta&#8209;)programmed in C or Assembler.  </div>
<h3 id="About_Learning_Coq">About Learning Coq</h3>
<div class="p">  To <i>start</i> learning Coq, I definitely recommend  <b>Software Foundations</b> by Pierce et al.: <a href="http://www.cis.upenn.edu/~bcpierce/sf/">http://www.cis.upenn.edu/~bcpierce/sf/</a> 
<ul>
 <li>  It is freely available on-line. </li>
<li>  It is very well written by very good teachers. <br/>
 The exercises are very progressive. With a very pragmatic approach, <i>SF</i> makes you really &ldquo;touch&rdquo; the Curry-Howard Isomorphism and digest Coq's features little by little. <br/>
 Actually, to my humble bibliographic knowledge, the 10 first chapters of <i>SF</i> are already the best book ever written on Computer Science. </li>
<li> It is addictive. <br/>
 We call it the <i>Video Game Effect</i>. <br/>
 And really, imagine yourself hacking some proofs: <i>&lsquo;Well, it is late, and there is a cool movie on TV&nbsp;&hellip; but&nbsp;&hellip; OK, just one more theorem&nbsp;&hellip;&rsquo;</i> and you end up at two in the morning with zombie-eyes but proud of your <i>n</i>-th four-stars exercise solved. </li>
</ul>
 </div>
<div class="p">  <i>SF</i> teaches you how to become a Coq beginner. The next step is then to learn how to really program and do engineering with Coq. For this, there is <b>Certified Programming with Dependent Types</b> by Adam Chlipala: <a href="http://adam.chlipala.net/cpdt/">http://adam.chlipala.net/cpdt/</a>. It is very interesting and seems to be the way to go. </div>
<div class="p">  I have been on it for some time now and I find it quite difficult though. It goes maybe too fast for me on many things and it has a lot of notations, ad-hoc libraries, and inter-dependencies. </div>
<div class="p">  So, let's take some time here to make some &ldquo;raw Coq&rdquo; with <i>good</i> notations (I mean textual, explicit, easy to remember), in slow motion, and trying to detail as much as possible, in the hope it will be useful for others. </div>
<div class="p">  The following is intended for Coq beginners like me, i.e.,  people who have been learning with <i>SF</i> (or other) for some time and who want to <i>program</i>.  </div>
<h3 id="Subsets_with_the__tt_sig__tt__Type">Subsets with the <tt>sig</tt> Type</h3>
<div class="p">  And let's start with <b>subsets</b>. The <i>fast</i> introduction is in <a href="http://adam.chlipala.net/cpdt/html/Subset.html">CPDT's Subset chapter</a> (which deals with much more than the <tt>sig</tt> type). </div>
<div class="p">  What follows is generated from a Coq development available  <a href="../media/subsets.v">on-line</a>; you can run it with your favourite Coq-environment. As I am a beginner, there are certainly things poorly implemented; the goal is to understand and move on to the next steps. Do not hesitate to correct me in the comments.  </div>
<div class="p"> The blue blocs are the actual Coq code, the grey/indented blocs are not executed (output examples, quotes from the standard library, etc.).  <style type="text/css">.comment { 
    display: inline;
    font-family: monospace;
    color: red; } 
.code, pre {
    font-size: 90%;
    margin-top: 5px;
    margin-bottom: 5px;
    padding: 4px;
    /* margin-left: 3em;  */
    /* margin-right: 3em; */
    display: block;
    font-family: monospace;  clear: both; } 
.maincoq {background-color: #ddf; clear: both; text-align: left;} 
pre {background-color: #eee; } 
.coqexample {background-color: #eee; clear: both;
margin-left: 5%; max-width: 92%; }

.id { display: inline; }

.id[type="constructor"] { 
    color: rgb(60%,0%,0%);
}

.id[type="var"] { 
    color: rgb(40%,0%,40%);
}

.id[type="variable"] { 
    color: rgb(40%,0%,40%);
}

.id[type="definition"] { 
    color: rgb(0%,40%,0%);
}

.id[type="abbreviation"] { 
    color: rgb(0%,40%,0%);
}

.id[type="lemma"] { 
    color: rgb(0%,40%,0%);
}

.id[type="instance"] { 
    color: rgb(0%,40%,0%);
}

.id[type="projection"] { 
    color: rgb(0%,40%,0%);
}

.id[type="method"] { 
    color: rgb(0%,40%,0%);
}

.id[type="inductive"] { 
    color: rgb(0%,0%,80%);
}

.id[type="record"] { 
    color: rgb(0%,0%,80%);
}

.id[type="class"] { 
    color: rgb(0%,0%,80%);
}

.id[type="keyword"] { 
 color : #cf1d1d;
/*     color: black; */
}
</style>  </div>
<h4 id="Prelude">Prelude</h4>
<div class="p">  We start with this classical command, everything else we need for now is already in Coq's pre-loaded module of the standard library (the <a href="http://coq.inria.fr/stdlib/Coq.Init.Prelude.html">Prelude</a> module). <div class="maincoq"><div class="code">
<span class="id" type="keyword">Set</span> <span class="id" type="keyword">Implicit</span> <span class="id" type="var">Arguments</span>.<br/>
</div>
</div>   The type <tt>sig</tt><small class="notebegin">(</small><small class="note">The name comes from &ldquo;Sigma&rdquo;; <a href="http://en.wikipedia.org/wiki/Intuitionistic_type_theory#.CE.A3-types">Î£-Types</a>.</small><small class="noteend">)</small> is defined in the <a href="http://coq.inria.fr/stdlib/Coq.Init.Specif.html">Specif</a> module  together with the associated notations: <div class="coqexample"><div class="code">
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">sig</span> (<span class="id" type="var">A</span> : <span class="id" type="keyword">Type</span>) (<span class="id" type="var">P</span> : <span class="id" type="var">A</span> -&gt; <span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">exist</span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span> : <span class="id" type="var">A</span>, <span class="id" type="var">P</span> <span class="id" type="var">x</span> -&gt; <span class="id" type="var">sig</span> <span class="id" type="var">P</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
<span class="id" type="keyword">Notation</span> "{ x | P }" := (<span class="id" type="var">sig</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> =&gt; <span class="id" type="var">P</span>)) : <span class="id" type="var">type_scope</span>.<br/>
<span class="id" type="var">Notation </span>"{ x : A | P }" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">sig</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span>:<span class="id" type="var">A</span> =&gt; <span class="id" type="var">P</span>)) : <span class="id" type="var">type_scope</span>.<br/>
</div>
</div> For instance, <tt>{x : nat | x &gt; 42}</tt> is the type of the naturals strictly bigger than <i>42</i>. </div>
<div class="p">  We also need <tt>False_rec</tt> (defined while defining the <tt>False</tt> in the <a href="http://coq.inria.fr/stdlib/Coq.Init.Logic.html">Logic</a> module). It will be useful to be able to put &ldquo;something&rdquo; for the cases which <i>never</i> happen  (i.e. an &ldquo;<tt>assert false</tt>&rdquo; in OCaml). </div>
<div class="p">  This deserves a few more notations:  <div class="maincoq"><div class="code">
<span class="id" type="var">Notation </span>"'Sig_no'"  := (<span class="id" type="var">False_rec</span> <span class="id" type="var">_</span> <span class="id" type="var">_</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 42).<br/>
<span class="id" type="var">Notation </span>"'Sig_yes' e" := (<span class="id" type="var">exist</span> <span class="id" type="var">_</span> <span class="id" type="var">e</span> <span class="id" type="var">_</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 42).<br/>
<span class="id" type="var">Notation </span>"'Sig_take' e" := <br/>
&nbsp;&nbsp;(<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span> <span class="id" type="var">Sig_yes</span> <span class="id" type="var">ex</span> =&gt; <span class="id" type="var">ex</span> <span class="id" type="keyword">end</span>) (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 42).<br/>
</div>
</div> </div>
<h4 id="Examples">Examples</h4>
<div class="p">   </div>
<h5 id="The_Trivial_One">The Trivial One</h5>
<div class="p">  Let's start with the simplest example I could find. A function returning the successor of a natural number, and telling so in its type: <div class="maincoq"><div class="code">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">succ_strong</span>: <span class="id" type="keyword">forall</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>), {<span class="id" type="var">m</span> : <span class="id" type="var">nat</span> | <span class="id" type="var">m</span> = <span class="id" type="var">S</span> <span class="id" type="var">n</span>}.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt; <span class="id" type="var">Sig_yes</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)). <span class="id" type="tactic">trivial</span>.<br/>
<span class="id" type="keyword">Defined</span>.<br/>
</div>
</div> It uses the <a href="http://coq.inria.fr/refman/Reference-Manual011.html#@tactic5">refine</a> tactic <small class="notebegin">(</small><small class="note">see also this <a href="http://coq.inria.fr/refman/Reference-Manual013.html#@tactic186">example</a></small><small class="noteend">)</small> which <blockquote><div class="p"><i>allows to give an exact proof, [&hellip;] like <tt>exact</tt>, with a big difference: the user can leave some holes (denoted by <tt>_</tt> or <tt>(_:type)</tt>) in the term. <tt>refine</tt> will generate as many subgoals as they are holes in the term.</i></div></blockquote> The <i>hack</i> is to use <tt>refine</tt> to provide the <i>body</i> of the function definition while in proof mode; and hence be able to provide the proof(s) of the specification part later.  In our case, there is only one generated subgoal (by the second &ldquo;<tt>_</tt>&rdquo; in the <tt>Sig_yes</tt> notation) and it is (solved by) <i>trivial</i>. </div>
<div class="p">  Without the <tt>refine</tt> tactic we would have to provide the <tt>(P x)</tt> argument of the <tt>exist</tt> constructor &ldquo;by hand&rdquo;: <div class="maincoq"><div class="code">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">succ_strong_by_hand</span>: <br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>), {<span class="id" type="var">m</span> : <span class="id" type="var">nat</span> | <span class="id" type="var">m</span> = <span class="id" type="var">S</span> <span class="id" type="var">n</span>} :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">exist</span> <span class="comment">(*&nbsp;The&nbsp;P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;&nbsp;*)</span> <span class="id" type="var">_</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;x&nbsp;:&nbsp;A&nbsp;&nbsp;&nbsp;*)</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;P&nbsp;x&nbsp;*)</span> (<span class="id" type="var">eq_refl</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)).<br/>
</div>
</div> The first underscore is inferred by Coq (not through <tt>refine</tt>): <div class="maincoq"><div class="code">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">succ_strong_no_inference_at_all</span>: <br/>
&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">n</span> : <span class="id" type="var">nat</span>), {<span class="id" type="var">m</span> : <span class="id" type="var">nat</span> | <span class="id" type="var">m</span> = <span class="id" type="var">S</span> <span class="id" type="var">n</span>} :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">exist</span> <span class="comment">(*&nbsp;The&nbsp;P&nbsp;:&nbsp;A&nbsp;-&gt;&nbsp;Prop&nbsp;&nbsp;*)</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">t</span> =&gt; <span class="id" type="var">eq</span> <span class="id" type="var">t</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;x&nbsp;:&nbsp;A&nbsp;&nbsp;&nbsp;*)</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;P&nbsp;x&nbsp;*)</span> (<span class="id" type="var">eq_refl</span> (<span class="id" type="var">S</span> <span class="id" type="var">n</span>)).<br/>
</div>
</div> Anyway, this would not scale to more complex types (it took me already quite some time to come up with the right <tt>eq</tt> and <tt>eq_refl</tt>). With <tt>refine</tt> instead, we let <i>underscores</i> for the &ldquo;proofs&rdquo; and we provide them later with usual Coq tactics. </div>
<div class="p">  Do not forget the <tt>Defined</tt> instead of <tt>Qed</tt>, so that Coq keeps the <i>proof</i> of the definition (with <tt>Qed</tt>,  <a href="http://coq.inria.fr/refman/Reference-Manual003.html#@command26">it would become</a> &ldquo;Opaque&rdquo;). </div>
<div class="p">  We can already check the generated OCaml code: <div class="maincoq"><div class="code">
<span class="id" type="var">Extraction</span> <span class="id" type="var">succ_strong</span>.<br/>
</div>
</div> <!-- Generator: GNU source-highlight 3.1.4
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-style: italic"><span style="color: #9A1900">(** val succ_strong : nat -&gt; nat **)</span></span>
<span style="font-weight: bold"><span style="color: #0000FF">let</span></span> succ_strong n <span style="color: #990000">=</span>
  <span style="color: #009900">S</span> n
</tt></pre>
 </div>
<div class="p">     </div>
<h5 id="A_Non_Total_Function">A Non-Total Function</h5>
<div class="p">  Let's see another example: <tt>pred_strong</tt> which can be called only for <tt>n &gt; 0</tt>.  <div class="maincoq"><div class="code">
<span class="id" type="keyword">Definition</span> <span class="id" type="var">pred_strong</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, <span class="id" type="var">n</span> &gt; 0 -&gt; {<span class="id" type="var">m</span> : <span class="id" type="var">nat</span> | <span class="id" type="var">n</span> = <span class="id" type="var">S</span> <span class="id" type="var">m</span>}.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">Sig_no</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">pn</span> =&gt; <span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">Sig_yes</span> <span class="id" type="var">pn</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>).<br/>
</div>
</div>         This time two goals remain to fill&nbsp;&hellip; <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="comment">(*&nbsp;n&nbsp;:&nbsp;nat&nbsp;&nbsp;&nbsp;&nbsp;_H&nbsp;:&nbsp;0&nbsp;&gt;&nbsp;0&nbsp;&nbsp;|-&nbsp;&nbsp;&nbsp;False&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">inversion</span> <span class="id" type="var">_H</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;&nbsp;n&nbsp;:&nbsp;nat&nbsp;&nbsp;&nbsp;pn&nbsp;:&nbsp;nat&nbsp;&nbsp;&nbsp;&nbsp;_H&nbsp;:&nbsp;S&nbsp;pn&nbsp;&gt;&nbsp;0&nbsp;|-&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;pn&nbsp;=&nbsp;S&nbsp;pn&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Proof&nbsp;Completed.&nbsp;*)</span><br/>
</div>
</div>      <tt>pred_strong</tt> would be now perfectly usable, but      we are not yet completely       happy because the proof is not &ldquo;well engineered&rdquo;:      it references internal-state stuff like &ldquo;<tt>_H</tt>&rdquo;, and it      depends on the order of the      subgoals<small class="notebegin">(</small><small class="note">CPDT has plenty of very interesting discussions and       justifications about the subject, e.g. in the      &ldquo;<a href="http://adam.chlipala.net/cpdt/html/Intro.html">Intro</a>&rdquo; or the      &ldquo;<a href="http://adam.chlipala.net/cpdt/html/Large.html">Large</a>&rdquo; chapters.</small><small class="noteend">)</small>.      <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="var">Restart</span>.<br/>
</div>
</div> We can  put everything together in one &ldquo;chain of tactics&rdquo;   without having references to local variables. We use the   <tt><a href="http://coq.inria.fr/refman/Reference-Manual012.html#@tactic181">solve</a></tt>   tactic which simply tries to <i>solve</i> the goal with one of the branches   given as arguments.   We match the goal looking for hypotheses looking like the previous   <tt>_H</tt> to invert them, for the other goal, we call <tt>auto</tt>.   <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">Sig_no</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">pn</span> =&gt; <span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">Sig_yes</span> <span class="id" type="var">pn</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>);<br/>
&nbsp;&nbsp;<span class="id" type="var">solve</span> <br/>
&nbsp;&nbsp;[ <span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span> <span class="id" type="var">H</span>: 0 &gt; 0 |- <span class="id" type="var">_</span> =&gt;  <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> <span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="tactic">auto</span> ].<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Proof&nbsp;Completed.&nbsp;*)</span><br/>
</div>
</div> That's nicer.   For posterity, we can also define the two following pieces of <tt>Ltac</tt>   which are reusable and <i>mostly</i> clean.   <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="var">Restart</span>.<br/>
</div>
</div>       <tt>solve_by_inversion</tt> will try to solve the goal by inverting      all the hypotheses<small class="notebegin">(</small><small class="note">There is a more complete/searching one <a href="http://coq.inria.fr/cocorico/solve%20by%20inversion%20%28tactic%29">on Cocorico</a>, the Coq wiki.</small><small class="noteend">)</small>.   <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Ltac</span> <span class="id" type="var">solve_by_inversion</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">H</span>:<span class="id" type="var">_</span> |- <span class="id" type="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">solve</span> [  <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span> | <span class="id" type="tactic">clear</span> <span class="id" type="var">H</span>; <span class="id" type="var">solve_by_inversion</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="tactic">fail</span> 2 "Could not solve by inversion" ]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
</div>
</div> <tt>invert_or_auto</tt> tries the previous one, and if it fails then   <tt>auto</tt>. <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Ltac</span> <span class="id" type="var">invert_or_auto</span> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> <span class="id" type="var">solve_by_inversion</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">solve</span> [ <span class="id" type="tactic">auto</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="tactic">fail</span> 2 "Could not solve by inversion nor auto" ].<br/>
</div>
</div> With them, we can solve this even more elegantly: <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">n</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">n</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">O</span> =&gt; <span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">Sig_no</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">S</span> <span class="id" type="var">pn</span> =&gt; <span class="id" type="keyword">fun</span> <span class="id" type="var">_</span> =&gt; <span class="id" type="var">Sig_yes</span> <span class="id" type="var">pn</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>); <span class="id" type="var">invert_or_auto</span>.<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;Proof&nbsp;Completed.&nbsp;*)</span><br/>
<span class="id" type="keyword">Defined</span>.<br/>
</div>
</div>   </div>
<div class="p">  Now the funny part: the function <tt>pred_strong</tt> takes as input an implicit natural number <i>n</i> and a &ldquo;proof that <i>n &gt; 0</i>&rdquo;: <div class="maincoq"><div class="code">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">two_gt_0</span> : 2 &gt; 0.<br/>
&nbsp;&nbsp;<span class="id" type="tactic">auto</span>.<br/>
<span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">compute</span> <span class="id" type="keyword">in</span> <span class="id" type="var">pred_strong</span> <span class="id" type="var">two_gt_0</span>.<br/>
</div>
</div> <pre>
= Sig_yes 1
: {m : nat | 2 = S m}
</pre>  Anyway, in OCaml, it still looks pretty <i>normal</i>: <div class="maincoq"><div class="code">
<span class="id" type="var">Extraction</span> <span class="id" type="var">pred_strong</span>.<br/>
</div>
</div> <!-- Generator: GNU source-highlight 3.1.4
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-style: italic"><span style="color: #9A1900">(** val pred_strong : nat -&gt; nat **)</span></span>

<span style="font-weight: bold"><span style="color: #0000FF">let</span></span> pred_strong <span style="color: #990000">=</span> <span style="font-weight: bold"><span style="color: #0000FF">function</span></span>
<span style="color: #990000">|</span> <span style="color: #009900">O</span> <span style="color: #990000">-&gt;</span> <span style="font-weight: bold"><span style="color: #0000FF">assert</span></span> <span style="font-weight: bold"><span style="color: #0000FF">false</span></span> <span style="font-style: italic"><span style="color: #9A1900">(* absurd case *)</span></span>
<span style="color: #990000">|</span> <span style="color: #009900">S</span> pn <span style="color: #990000">-&gt;</span> pn 
</tt></pre>
   The eager reader can continue with CPDT's <a href="http://adam.chlipala.net/cpdt/html/Subset.html">Subset</a> chapter to see more implementations of &ldquo;<tt>pred</tt>&rdquo; with other rich dependent types.  </div>
<h5 id="A__tt_List_map__tt_">A <tt>List.map</tt></h5>
<div class="p">  Here is an implementation of <tt>List.map</tt> with a <tt>sig</tt> return type specifying what the result actually <i>is</i>.  <div class="maincoq"><div class="code">
<span class="id" type="keyword">Section</span> <span class="id" type="var">List_map</span>.<br/>
</div>
</div> We use Coq's basic lists <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Import</span> <span class="id" type="var">List</span>.<br/>
</div>
</div> and we describe what the map function should do with an      inductive proposition. <tt>map_spec</tt> links      the input list, the input function and the resulting function.      <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Inductive</span> <span class="id" type="var">map_spec</span> (<span class="id" type="var">A</span> <span class="id" type="var">B</span>: <span class="id" type="keyword">Set</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">A</span> -&gt; <span class="id" type="var">B</span>) -&gt; (<span class="id" type="var">list</span> <span class="id" type="var">A</span>) -&gt; (<span class="id" type="var">list</span> <span class="id" type="var">B</span>) -&gt; <span class="id" type="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="var">ms_empty</span>: <span class="id" type="keyword">forall</span> <span class="id" type="var">f</span>, <span class="id" type="var">map_spec</span>  <span class="id" type="var">f</span> <span class="id" type="var">nil</span> <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;| <span class="id" type="var">ms_step</span>: <span class="id" type="keyword">forall</span> <span class="id" type="var">f</span> <span class="id" type="var">a</span> <span class="id" type="var">la</span> <span class="id" type="var">b</span> <span class="id" type="var">lb</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">b</span> = <span class="id" type="var">f</span> <span class="id" type="var">a</span>) -&gt; <span class="id" type="var">map_spec</span> <span class="id" type="var">f</span> <span class="id" type="var">la</span> <span class="id" type="var">lb</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">map_spec</span> <span class="id" type="var">f</span> (<span class="id" type="var">a</span> :: <span class="id" type="var">la</span>) (<span class="id" type="var">b</span> :: <span class="id" type="var">lb</span>).<br/>
</div>
</div>  </div>
<div class="p">      Here is the signature of the <tt>specified_map</tt>: <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Definition</span> <span class="id" type="var">specified_map</span> (<span class="id" type="var">A</span> <span class="id" type="var">B</span>: <span class="id" type="keyword">Set</span>): <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">f</span>: <span class="id" type="var">A</span> -&gt; <span class="id" type="var">B</span>) (<span class="id" type="var">l</span>: <span class="id" type="var">list</span> <span class="id" type="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="var">lm</span> : <span class="id" type="var">list</span> <span class="id" type="var">B</span> | <span class="id" type="var">map_spec</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">lm</span> }.<br/>
</div>
</div>       Simply because it is fun, we use the      <tt><a href="http://coq.inria.fr/refman/Reference-Manual011.html#@command230">Proof with</a></tt> command which gives a meaning to the &ldquo;<tt>...</tt>&rdquo; notation.      We feed <tt>auto</tt> with the constructors of <tt>map_spec</tt> (this      could have been done also with a       <a href="http://coq.inria.fr/refman/Reference-Manual011.html#@command218">Hint</a>).      <div class="maincoq"><div class="code">
&nbsp;&nbsp;<span class="id" type="keyword">Proof</span> <span class="id" type="keyword">with</span> <span class="id" type="tactic">eauto</span> <span class="id" type="keyword">using</span> <span class="id" type="var">ms_empty</span>, <span class="id" type="var">ms_step</span>.<br/>
</div>
</div> Without the notation <tt>Sig_take</tt>, we simply do pattern matching      with one case: <div class="maincoq"><div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<span class="id" type="var">fix</span> <span class="id" type="var">fx</span> (<span class="id" type="var">f</span>: <span class="id" type="var">A</span> -&gt; <span class="id" type="var">B</span>) (<span class="id" type="var">l</span>: <span class="id" type="var">list</span> <span class="id" type="var">A</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="var">lm</span> : <span class="id" type="var">list</span> <span class="id" type="var">B</span> | <span class="id" type="var">map_spec</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">lm</span> } :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">Sig_yes</span> <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">cons</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">fx</span> <span class="id" type="var">f</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">Sig_yes</span> <span class="id" type="var">ll</span> =&gt; <span class="id" type="var">Sig_yes</span> (<span class="id" type="var">f</span> <span class="id" type="var">h</span> :: <span class="id" type="var">ll</span>)  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Proof&nbsp;Completed.&nbsp;*)</span><br/>
</div>
</div> and that's <i>done</i>.        But If we want to play with the notation, we        introduce a tiny problem: <div class="maincoq"><div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Restart</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<span class="id" type="var">fix</span> <span class="id" type="var">fx</span> (<span class="id" type="var">f</span>: <span class="id" type="var">A</span> -&gt; <span class="id" type="var">B</span>) (<span class="id" type="var">l</span>: <span class="id" type="var">list</span> <span class="id" type="var">A</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="var">lm</span> : <span class="id" type="var">list</span> <span class="id" type="var">B</span> | <span class="id" type="var">map_spec</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">lm</span> } :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">Sig_yes</span> <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">cons</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <span class="id" type="var">Sig_yes</span> (<span class="id" type="var">f</span> <span class="id" type="var">h</span> :: (<span class="id" type="var">Sig_take</span> <span class="id" type="var">fx</span> <span class="id" type="var">f</span> <span class="id" type="var">t</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)...<br/>
</div>
</div> There we are stuck with a <tt>(let (ex, _) := fx f t in ex)</tt>        in the middle of the goal         which <tt>auto</tt> does not want to expand any more&nbsp;&hellip; <div class="maincoq"><div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Restart</span>.<br/>
</div>
</div> We can ask Coq to force it: <div class="maincoq"><div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<span class="id" type="var">fix</span> <span class="id" type="var">fx</span> (<span class="id" type="var">f</span>: <span class="id" type="var">A</span> -&gt; <span class="id" type="var">B</span>) (<span class="id" type="var">l</span>: <span class="id" type="var">list</span> <span class="id" type="var">A</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="var">lm</span> : <span class="id" type="var">list</span> <span class="id" type="var">B</span> | <span class="id" type="var">map_spec</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">lm</span> } :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">Sig_yes</span> <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">cons</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <span class="id" type="var">Sig_yes</span> (<span class="id" type="var">f</span> <span class="id" type="var">h</span> :: (<span class="id" type="var">Sig_take</span> <span class="id" type="var">fx</span> <span class="id" type="var">f</span> <span class="id" type="var">t</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">try</span> (<span class="id" type="tactic">destruct</span> (<span class="id" type="var">fx</span> <span class="id" type="var">f</span> <span class="id" type="var">t</span>))...<br/>
</div>
</div> And get the &ldquo;<tt>Proof Completed</tt>&rdquo;         but we can still try to make something cleaner. <div class="maincoq"><div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">Restart</span>.<br/>
</div>
</div>        After a bit of         <a href="http://thread.gmane.org/gmane.science.mathematics.logic.coq.club/1115/focus=1119">googling</a>-trial-and-error, we get a tactic to force the <tt>destruct</tt>        on our notation.        <div class="maincoq"><div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">Ltac</span> <span class="id" type="var">with_sig_take</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">repeat</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">goal</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| [ |- <span class="id" type="var">context</span>[ <span class="id" type="keyword">match</span> ?<span class="id" type="var">E</span> <span class="id" type="keyword">with</span> <span class="id" type="var">Sig_yes</span> <span class="id" type="var">x</span> =&gt; <span class="id" type="var">_</span> <span class="id" type="keyword">end</span> ] ] =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">idtac</span> "Destructing" <span class="id" type="var">E</span>; <span class="id" type="tactic">destruct</span> <span class="id" type="var">E</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="tactic">refine</span> (<span class="id" type="var">fix</span> <span class="id" type="var">fx</span> (<span class="id" type="var">f</span>: <span class="id" type="var">A</span> -&gt; <span class="id" type="var">B</span>) (<span class="id" type="var">l</span>: <span class="id" type="var">list</span> <span class="id" type="var">A</span>):<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ <span class="id" type="var">lm</span> : <span class="id" type="var">list</span> <span class="id" type="var">B</span> | <span class="id" type="var">map_spec</span> <span class="id" type="var">f</span> <span class="id" type="var">l</span> <span class="id" type="var">lm</span> } :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">l</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">nil</span> =&gt; <span class="id" type="var">Sig_yes</span> <span class="id" type="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">cons</span> <span class="id" type="var">h</span> <span class="id" type="var">t</span> =&gt; <span class="id" type="var">Sig_yes</span> (<span class="id" type="var">f</span> <span class="id" type="var">h</span> :: (<span class="id" type="var">Sig_take</span> <span class="id" type="var">fx</span> <span class="id" type="var">f</span> <span class="id" type="var">t</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="var">with_sig_take</span>...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;Proof&nbsp;Completed.&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">Defined</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="var">List_map</span>.<br/>
</div>
</div> </div>
<div class="p"> Let's do some tests&nbsp;&hellip; <div class="maincoq"><div class="code">
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">compute</span> <span class="id" type="keyword">in</span><br/>
&nbsp;&nbsp;(<span class="id" type="var">specified_map</span> (<span class="id" type="keyword">fun</span> <span class="id" type="var">x</span> =&gt; <span class="id" type="var">x</span> + 42) (0 :: 1 :: 2 :: 4 :: <span class="id" type="var">nil</span>)).<br/>
</div>
</div> <pre>
= Sig_yes (42 :: 43 :: 44 :: 46 :: nil)
: {lm : list nat |
 map_spec (fun x : nat =&gt; x + 42) (0 :: 1 :: 2 :: 4 :: nil) lm}
</pre> </div>
<div class="p">  We can also call <tt>pred_strong</tt> on a list of <i>wrapped</i> positive naturals: <div class="maincoq"><div class="code">
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">strictly_positive</span> : <span class="id" type="keyword">Set</span> :=<br/>
| <span class="id" type="var">gt_0</span>: <span class="id" type="keyword">forall</span> <span class="id" type="var">n</span> : <span class="id" type="var">nat</span>, (<span class="id" type="var">n</span> &gt; 0) -&gt; <span class="id" type="var">strictly_positive</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">one_gt_0</span>: 1 &gt; 0. <span class="id" type="tactic">auto</span>. <span class="id" type="keyword">Qed</span>.<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">three_gt_0</span>: 3 &gt; 0. <span class="id" type="tactic">auto</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Eval</span> <span class="id" type="tactic">compute</span> <span class="id" type="keyword">in</span> <br/>
&nbsp;&nbsp;(<span class="id" type="var">specified_map</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="keyword">fun</span> <span class="id" type="var">t</span> =&gt; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">t</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" type="var">gt_0</span> <span class="id" type="var">x</span> <span class="id" type="var">x_gt_0</span> =&gt; <span class="id" type="var">Sig_take</span> <span class="id" type="var">pred_strong</span> <span class="id" type="var">x_gt_0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">end</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" type="var">gt_0</span> <span class="id" type="var">one_gt_0</span>) :: (<span class="id" type="var">gt_0</span> <span class="id" type="var">two_gt_0</span>) :: <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">gt_0</span> <span class="id" type="var">three_gt_0</span>) :: <span class="id" type="var">nil</span>)).<br/>
</div>
</div> <pre>
= Sig_yes (0 :: 1 :: 2 :: nil)
: {lm : list nat |
  map_spec
    (fun t : strictly_positive =&gt;
     match t with
     | gt_0 x x_gt_0 =&gt; let (ex, _) := pred_strong x_gt_0 in ex
     end) (gt_0 one_gt_0 :: gt_0 two_gt_0 :: gt_0 three_gt_0 :: nil) lm}
</pre>  </div>
<div class="p"> Finally, let's have a look at the OCaml code: <div class="maincoq"><div class="code">
<span class="id" type="var">Recursive Extraction</span> <span class="id" type="var">specified_map</span>.<br/>
</div>
</div> <!-- Generator: GNU source-highlight 3.1.4
by Lorenzo Bettini
http://www.lorenzobettini.it
http://www.gnu.org/software/src-highlite -->
<pre><tt><span style="font-weight: bold"><span style="color: #0000FF">type</span></span> 'a <span style="color: #009900">list</span> <span style="color: #990000">=</span>
<span style="color: #990000">|</span> <span style="color: #009900">Nil</span>
<span style="color: #990000">|</span> <span style="color: #009900">Cons</span> <span style="font-weight: bold"><span style="color: #0000FF">of</span></span> 'a <span style="color: #990000">*</span> 'a <span style="color: #009900">list</span>

<span style="font-weight: bold"><span style="color: #0000FF">type</span></span> 'a sig0 <span style="color: #990000">=</span>
  'a
  <span style="font-style: italic"><span style="color: #9A1900">(* singleton inductive, whose constructor was exist *)</span></span>

<span style="font-style: italic"><span style="color: #9A1900">(** val specified_map : ('a1 -&gt; 'a2) -&gt; 'a1 list -&gt; 'a2 list **)</span></span>

<span style="font-weight: bold"><span style="color: #0000FF">let</span></span> <span style="font-weight: bold"><span style="color: #0000FF">rec</span></span> specified_map f <span style="color: #990000">=</span> <span style="font-weight: bold"><span style="color: #0000FF">function</span></span>
<span style="color: #990000">|</span> <span style="color: #009900">Nil</span> <span style="color: #990000">-&gt;</span> <span style="color: #009900">Nil</span>
<span style="color: #990000">|</span> <span style="color: #009900">Cons</span> <span style="color: #990000">(</span>h<span style="color: #990000">,</span> t<span style="color: #990000">)</span> <span style="color: #990000">-&gt;</span> <span style="color: #009900">Cons</span> <span style="color: #990000">((</span>f h<span style="color: #990000">),</span> <span style="color: #990000">(</span>specified_map f t<span style="color: #990000">))</span>
</tt></pre>
  </div>
<div class="p"> </div>
<h3 id="Conclusion">Conclusion</h3>
<div class="p">  That's all for today. Next time, again from the <a href="http://coq.inria.fr/stdlib/Coq.Init.Specif.html">Specif</a> module: the <tt>sumbool</tt> type.   </div>
<div class="p"><hr/><div id="disqus_thread"></div>
  <script type="text/javascript">
      var disqus_shortname = 'sebmondetblog'; 
      // required: replace example with your forum shortname
  
      // The following are highly recommended additional
      // parameters. Remove the slashes in front to use.
      var disqus_identifier = 'coqtests-01-subsets';
      var disqus_url = 'http://seb.mondet.org/./blog/post/coqtests-01-subsets.html';
  
      /* * * DON'T EDIT BELOW THIS LINE * * */
      (function() {
          var dsq = document.createElement('script');
          dsq.type = 'text/javascript'; dsq.async = true;
          dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
          (document.getElementsByTagName('head')[0] ||
             document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
  </script>
  <noscript>Please enable JavaScript to view the
  <a href="http://disqus.com/?ref_noscript">comments powered
  by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">blog
  comments powered by <span class="logo-disqus">Disqus</span></a></div>

<div id="pagefoot" />
</div>
<div class="sidepane">
<h1>Sebastien Mondet</h1><br/>
<b>Menu: </b><div class="p">
<ul>
  <li> <a href="../../index.html">Home</a>  </li>
<li> <a href="../../publications.html">Publications</a>  </li>
<li> <a href="../../software.html">Software</a>  </li>
<li> <a href="../../blog/index.html">Blog</a> </li>
</ul>
 </div>
<br/>
<br/>
<br/>
<br/>
<br/>
<small><div class="p"> Site generated thanks to  <a href="http://seb.mondet.org/bracetax/">bracetax</a>, <a href="http://martin.jambon.free.fr/camlmix/">camlmix</a>, <a href="http://seb.mondet.org/sebib/">sebib</a>, and <a href="https://github.com/smondet/dibrawi">more&nbsp;&hellip;</a> <br/>
 Updated on Sat, 10 Dec 2011 12:46:34 -0500. <br/>
 <a href="http://seb.mondet.org">Sebastien Mondet</a><br/>
<br/>
 </small>
<a href="http://caml.inria.fr/">
  <img src="http://caml.inria.fr//pub/logos/caml-powered.80x30.png"
       alt="Powered by Caml"
       style="border: none;" />
</a> </div>
<br/>
</div>
</body></html>
